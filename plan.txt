operator overloading []
- access and edit branches

Parse json file
- create json data structure from json file
- automatically type cast?

Json data structure
- create json
- output json file



What is json?
    Data types: string, number, boolean, null, Array, object (key value pairs)
    Can only store in Array or Object so, if want organize lot of data, use those.

    Object:
        -keys and values must be separated by double quotes
        -key value pairs separated by comma
        -keys must be strings


Data structure idea:
- std::string - string
- int - number w/o decimal
- double - number w/ decimal
- std::vector - Array
- std::unordered_map - Object
# Need to make a variant which can be any of the possible types
# Or a Tagged Union if that doesnt work
# or without special variant ds?

Idea 1: 
Parse json
Store types as a variant
- VariantX stores type vector<variantX>
    - need to define vector<variantX> to make variantX
    - need to define variantX to make vector<variantX>
    - BRUH

Idea 2:
Different data types in Json have different qualities.
    - qualities hold for the immediate scope of the data type -- not deeper into nested data types
Qualities:
Object: 
    - key and value separated by ':'
    - key-value pairs separated by ','
    - strings as keys
    -- values all json data types
    # randomness in value
    # shown by open and close {}
Array:
    - each element separated by ','
    -- elements all json data types
    # shown by open and close []
String:
    - meaningful json characters lose meaning within scope
    -- all characters allowed
    # shown by open and close ""
Number:
    -- only numberical characters, '-' or '.'
    ## outside everything, inside array, inside object value
boolean / null:
    - only true or false / only null

Need to know which data type i'm currently in
- keep track using stack GENIUS
- data type need to keep track of state its in to enforce its proper
- OBSERVATION: outside of data type to create it (push()), inside data type to leave it (pop())

Data Type states:
Object:
- before key (" or })
- colon
- before value
- after value (, or })

Array:
- before value
- comma
- after value

String:
- 


Idea 3:
Use classes/objects to represent each data type when parsing?
    - can just call within another object
        - don't need stack of "enum data types" then
            - how to handle file reading then?
                - new class which all data types call which handle getting chars


ObjectHandler:
    constructor(&JsonVal, &TypeStack, state)
    enum class state
        operator++(): 
            change state
    unordered_map<JsonVal, JsonVal> progress;
    string seenKey = null;
    JsonVal seenVal = null;
    store(): 
        (call when value finished (key,value))
    handle(char* ch):
        if state == beforeKey:
            if ch is not (" or }): throw error
            if (ch is "): StringHandler key(JsonVal, TypeStack, state)


Idea 4: whole - read char from file, store/errorhandle char based on current jsontype and jsonTypeState
Parts:
    read char from file
    store partially completed jsontypes when moving on to deeper nested types
    identify jsontype
    create jsontype
    keep track of jsonTypeState
    keep track of progress for jsonType
    error handle char
    store completed jsonType
    
Structure 1: No type stack
characterReader class:
    char getChar(bool ignoreWhitespace);

ObjectHandler:
    enum class state
        operator++(): 
            change state
    constructor(&JsonVal): set state
    unordered_map<String, JsonVal> progress;
    string seenKey = null;
    JsonVal seenVal = null;

    unordered_map<String, JsonVal> handle(){
        char c = characterReader::getChar()
        while (c != })
            if state == beforeKey:
                if ch is not (" or }): throw error
                if (ch is "): 
                    StringHandler key(JsonVal);
                    seenKey = key.handle()
                    this->state++;
                else if (ch is }): // Empty object
                    return progress;
            if state == Colon:
                if ch is not ':' : throw error
                if ch is ':' : this->state++
            if state == beforeValue:
                if {:
                if ":
                if number:
                if -:
                if [:
                

            c = characterReader::getChar()
    }


helper function:
    handleDataType(): 
        - returns handler for data type given char
        - used when any data type can come next

    convertJsonVal():
        - converts data structure (unordered_map, etc) into jsonVal

    getChar():
        - gets next char in file



Implement error detection and parse separately?

Due to number data type and in small part (true, false, null) types, much better to not deal with first char
of data type outside of dataTypeHandler
{key : val}
    - outside of objectHandler (index before '{') detect via peek next
    - go inside (index is at '{')
    - inside objectHandler increment index until peekNext() isnt whitespace and is '"'
    - still outside stringHandler, spawn string handler
    - when inside string handler and at second '"', increment to next char and return
    - continue through ':' and value
    - when see '}' at correct state, increment to next char and return
[ele, ele, ele]
    - outside of arrayHandler (index before '[') detect via peek next
    - go inside (index is at '[')
    - inside arrayHandler increment index until peekNext() isnt whitespace and is a data type indicator
    - still outside datatypeHandler, spawn data type handler
    - when inside datatypeHandler and at last char, increment to next char and return
    - when see ']' at correct state, increment to next char and return
"asdf"
    - outside of string handler (index before '"') detect via peek next
    - go inside (index is at '"')
    - when see second '"' increment to next char and return
1234  -1234  1234.1234  -1234.1234
    - outside of number handler (index before '-' or digit) detect via peek next    
    - go inside (index is at '-' or digit)
    - when see that next is not an accepted value and its end of number, increment to next char and return
true
    - outside of true handler (index before 't') detect via peek next
    - go inside (index is at 't')
    - when at 'e', increment to next char and return
false
    - outside of false handler (index before 'f') detect via peek next
    - go inside (index is at 'f')
    - when at 'e', increment to next char and return
null
    - outside of true handler (index before 'n') detect via peek next
    - go inside (index is at 'n')
    - when at second 'l', increment to next char and return
- "increment to next char and return" handled by parent when getting next?
New structure of CharReader to get not 1 but 2 chars: V1
    getChar(): now reloads the line when the NEXT not current index is out of bounds // Gonna run forever
    canGet(): same
    canPeek(): checks if the NEXT not current index is out of bounds - only false when last char bc getChar()
    peekChar(): returns the next char which is guaranteed to be seen by ^
New structure of CharReader to get not 1 but 2 chars: V2
    Needs:
        - get every char in the file
        - peek next char for every char except last open
            - for last one we only need to get it
    Last one:
Approaches:
    return two chars (gotten, peeked)  
        char[2] getTwo(), bool lastOne()
        - have to do something weird for the very last one
    two static member variables gotten, peaked
        getChar(), canGetPeek()
        - probably same as last approach
    separate increment and getChar
        increment(), getChar(), fileEnd()
Cases:
    handler calls CharReader to use the char and move on to next
    handler calls CharReader to just see the next one - OR just see the current one without increment


Idea 5: regex




Comments:
put include in .cpp or .hpp?
what about duplicate includes?
think about file and class organization later
use inheritance
can try defining own exception
    - exception throwing class
what happens if JsonVal in handlers + other return types created in handle() fall out of scope?



