operator overloading []
- access and edit branches

Parse json file
- create json data structure from json file
- automatically type cast?

Json data structure
- create json
- output json file



What is json?
    Data types: string, number, boolean, null, Array, object (key value pairs)
    Can only store in Array or Object so, if want organize lot of data, use those.

    Object:
        -keys and values must be separated by double quotes
        -key value pairs separated by comma
        -keys must be strings


Data structure idea:
- std::string - string
- int - number w/o decimal
- double - number w/ decimal
- std::vector - Array
- std::unordered_map - Object
# Need to make a variant which can be any of the possible types
# Or a Tagged Union if that doesnt work
# or without special variant ds?

Idea 1: 
Parse json
Store types as a variant
- VariantX stores type vector<variantX>
    - need to define vector<variantX> to make variantX
    - need to define variantX to make vector<variantX>
    - BRUH

Idea 2:
Different data types in Json have different qualities.
    - qualities hold for the immediate scope of the data type -- not deeper into nested data types
Qualities:
Object: 
    - key and value separated by ':'
    - key-value pairs separated by ','
    - strings as keys
    -- values all json data types
    # randomness in value
    # shown by open and close {}
Array:
    - each element separated by ','
    -- elements all json data types
    # shown by open and close []
String:
    - meaningful json characters lose meaning within scope
    -- all characters allowed
    # shown by open and close ""
Number:
    -- only numberical characters, '-' or '.'
    ## outside everything, inside array, inside object value
boolean / null:
    - only true or false / only null

Need to know which data type i'm currently in
- keep track using stack GENIUS
- data type need to keep track of state its in to enforce its proper
- OBSERVATION: outside of data type to create it (push()), inside data type to leave it (pop())

Data Type states:
Object:
- before key (" or })
- colon
- before value
- after value (, or })

Array:
- before value
- comma
- after value

String:
- 


Idea 3:
Use classes/objects to represent each data type when parsing?
    - can just call within another object
        - don't need stack of "enum data types" then
            - how to handle file reading then?
                - new class which all data types call which handle getting chars


ObjectHandler:
    constructor(&JsonVal, &TypeStack, state)
    enum class state
        operator++(): 
            change state
    unordered_map<JsonVal, JsonVal> progress;
    string seenKey = null;
    JsonVal seenVal = null;
    store(): 
        (call when value finished (key,value))
    handle(char* ch):
        if state == beforeKey:
            if ch is not (" or }): throw error
            if (ch is "): StringHandler key(JsonVal, TypeStack, state)


Idea 4: whole - read char from file, store/errorhandle char based on current jsontype and jsonTypeState
Parts:
    read char from file
    store partially completed jsontypes when moving on to deeper nested types
    identify jsontype
    create jsontype
    keep track of jsonTypeState
    keep track of progress for jsonType
    error handle char
    store completed jsonType
    
Structure 1: No type stack
characterReader class:
    char getChar(bool ignoreWhitespace);

ObjectHandler:
    enum class state
        operator++(): 
            change state
    constructor(&JsonVal): set state
    unordered_map<String, JsonVal> progress;
    string seenKey = null;
    JsonVal seenVal = null;

    unordered_map<String, JsonVal> handle(){
        char c = characterReader::getChar()
        while (c != })
            if state == beforeKey:
                if ch is not (" or }): throw error
                if (ch is "): 
                    StringHandler key(JsonVal);
                    seenKey = key.handle()
                    this->state++;
                else if (ch is }): // Empty object
                    return progress;
            if state == Colon:
                if ch is not ':' : throw error
                if ch is ':' : this->state++
            if state == beforeValue:
                if {:
                if ":
                if number:
                if -:
                if [:
                

            c = characterReader::getChar()
    }


helper function:
    handleDataType(): 
        - returns handler for data type given char
        - used when any data type can come next

    convertJsonVal():
        - converts data structure (unordered_map, etc) into jsonVal

    getChar():
        - gets next char in file



Implement error detection and parse separately?


Idea 5: regex




Comments:
put include in .cpp or .hpp?
what about duplicate includes?
think about file and class organization later
use inheritance
can try defining own exception
    - exception throwing class
what happens if JsonVal in handlers + other return types created in handle() fall out of scope?



